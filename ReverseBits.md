### Reverse Bits
*Reverse bits of a given 32 bits unsigned integer.

* 给定32位无符号整数的反向位输出 

例如：43261596 二进制表示 (00000010100101000001111010011100), return 964176192 二进制表示00111001011110000010100101000000).

``` java
public class Solution {
    public int reverseBits(int n) {
       if(n==0) return 0;
       int result =0;
       for (int i=0;i<32;i++) {
          result <<=1;
          if((n&1)==1) result++; //or result+=(n&1)
          n>>=1;
       }
       return result;
   }
}
```
* 此方法是@sljamca的高票答案，详解如下
给定32位无符号整数的反向位。

例如，给定输入43261596（以二进制表示为00000010100101000001111010011100），返回964176192（以二进制表示为00111001011110000010100101000000）。
我们首先将结果初始化为0.然后我们迭代
0〜31（整数为32位）。在每次迭代中：
我们首先将结果向左移动1位。
然后，如果输入n的最后一位数字为1，我们将结果加1。至
找到n的最后一位数，我们只做：（n＆1）
例如，如果n = 5（101），n＆1 = 101＆001 = 001 = 1;
然而，如果n = 2（10），n＆1 = 10＆01 = 0）。
最后，我们通过向右移位1来更新n（n >> = 1）
在迭代结束时，我们返回结果。

例如，如果输入n = 13（二进制表示为
0000_0000_0000_0000_0000_0000_0000_1101，“_”用于可读性），
调用reverseBits（13）应该返回：
1011_0000_0000_0000_0000_0000_0000_0000

这里是我们的算法如何工作输入n = 13：

最初，result = 0 = 0000_0000_0000_0000_0000_0000_0000_0000，
n = 13 = 0000_0000_0000_0000_0000_0000_0000_1101

启动循环：
i = 0：
result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0000。
n＆1 = 0000_0000_0000_0000_0000_0000_0000_1101＆
0000_0000_0000_0000_0000_0000_0000_0001 =
0000_0000_0000_0000_0000_0000_0000_0001 = 1
因此result = result + 1 =
0000_0000_0000_0000_0000_0000_0000_0000 +
0000_0000_0000_0000_0000_0000_0000_0001 =
0000_0000_0000_0000_0000_0000_0000_0001 = 1
我们右移n 1（n >> = 1）得到：
n = 0000_0000_0000_0000_0000_0000_0000_0110。
然后我们进入下一次迭代。

i = 1：
result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0010;
n＆1 = 0000_0000_0000_0000_0000_0000_0000_0110＆
0000_0000_0000_0000_0000_0000_0000_0001
= 0000_0000_0000_0000_0000_0000_0000_0000 = 0;
因此我们不增加结果。
我们右移n 1（n >> = 1）得到：
n = 0000_0000_0000_0000_0000_0000_0000_0011。
然后我们进入下一次迭代。

i = 2：
result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0100。
n＆1 = 0000_0000_0000_0000_0000_0000_0000_0011＆
0000_0000_0000_0000_0000_0000_0000_0001 =
0000_0000_0000_0000_0000_0000_0000_0001 = 1
因此result = result + 1 =
0000_0000_0000_0000_0000_0000_0000_0100 +
0000_0000_0000_0000_0000_0000_0000_0001 =
result = 0000_0000_0000_0000_0000_0000_0000_0101
我们右移n乘以1得到：
n = 0000_0000_0000_0000_0000_0000_0000_0001。
然后我们进入下一次迭代。

i = 3：
result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_1010。
n＆1 = 0000_0000_0000_0000_0000_0000_0000_0001＆
0000_0000_0000_0000_0000_0000_0000_0001 =
0000_0000_0000_0000_0000_0000_0000_0001 = 1
因此result = result + 1 =
= 0000_0000_0000_0000_0000_0000_0000_1011
我们右移n乘以1得到：
n = 0000_0000_0000_0000_0000_0000_0000_0000 = 0。

现在，从这里到迭代结束，n是0，所以（n＆1）
将始终为0，且n >> = 1不会改变n。唯一的变化
将结果<< = 1，即将结果向左移动1位。
由于我们有i = 4到i = 31的迭代左，这将导致
在填充28 0的结果右边。即在结束，我们得到
result = 1011_0000_0000_0000_0000_0000_0000_0000

``` java
public class Solution {
     public int reverseBits(int n) {
          int result =0;
          for(int i=31;i>=0;i--, result>>=1) {
               result |= ((n&1)<<i);
           }
           return result;
        }
 }
```
``` python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        result=0
        for i in range(32):
            result+=((n>>i)&1)<<(31-i)
        return result
```
``` python
class Solution:
    def reverseBits(self, n):
        result = bin(n).replace('0b', '')
        result = '0'*(32-len(result)) +result
        result = result[::-1]
        return int(result,2)
```































